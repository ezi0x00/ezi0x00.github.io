---
title: "Deep Analysis of Emotet Banking Trojan (TA542 APT)"
classes: wide
header:
  teaser: /assets/images/Malware-Analysis/Emotet/emotet.png
ribbon: blue
description: "Emotet is a banking Trojan designed to steal financial information from online banking sessions through man-in-the-browser (MITB) attacks, but since 2017 it has been observed distributing other malware families, such as IcedID, Zeus Panda and TrickBot. The malware has been actively developed, with each new version changing or extending its capabilities."
categories:
  - Malware Analysis
toc: true
---
# <u> Emotet Live Cycle </u>

[![0](/assets/images/Malware-Analysis/Emotet/0.png)](/assets/images/Malware-Analysis/Emotet/0.png)


# <u>First Stage: Microsoft Word Document [Downloader]</u>

| Fingerprint                       | Value                                                        |
| --------------------------------- | ------------------------------------------------------------ |
| MD5:                                | 57be28414e61ff58a6b52fc3c1b70b7f                             |
| SHA-1:                              | c4fbb54b194c1303897ac869811a274303d27f38                     |
| SHA-256:                            | 01b1232dee4ac560ba34061aa65f5de79c7182de3b6f313ad1a83c39ce61550c |
| File Type:                          | Composite Document File V2 Document                          |
| Create Time/Date:                   | Fri Mar 15 16:04:00 2019                                     |

The first stage of this malware is an microsoft Word formats (.doc) use VBA (Visual Basic for Applications) AutoOpen macros to execute code that downloads the Emotet loader. Emotet Word documents contain embedded images that request the user to click the `Enable Editing` button to disable Microsoft Word’s read-only mode (Protected View) and `Enable Content` to cause the macro to run.

[![1](/assets/images/Malware-Analysis/Emotet/1.png)](/assets/images/Malware-Analysis/Emotet/1.png)

To view the macro click on Developer tab, click Visual Basic and you can see the macro.

[![2](/assets/images/Malware-Analysis/Emotet/2.png)](/assets/images/Malware-Analysis/Emotet/2.png) | [![3](/assets/images/Malware-Analysis/Emotet/3.png)](/assets/images/Malware-Analysis/Emotet/3.png)

## VBA Analysis

The documents contain obfuscated VBA code let's analysis the most important parts in it

[![4](/assets/images/Malware-Analysis/Emotet/4.png)](/assets/images/Malware-Analysis/Emotet/4.png)

`autoopen()` function which gets executed when the document is opened

[![5](/assets/images/Malware-Analysis/Emotet/5.png)](/assets/images/Malware-Analysis/Emotet/5.png)

`powershell -e`
 first thing after execution the code creation of string by "powershell -e".

[![6](/assets/images/Malware-Analysis/Emotet/6.png)](/assets/images/Malware-Analysis/Emotet/6.png)

`dBCWQQZ = winmgmts:Win32_Process`
 then variable dBCwQQZ is defined with the string "winmgmts:Win32_Process".

[![7](/assets/images/Malware-Analysis/Emotet/7.png)](/assets/images/Malware-Analysis/Emotet/7.png)

`TCXD_U =GetObject(winmgmts:Win32_ProcessStartup)`
 then variable TCXD_U is defined with the string "GetObject(winmgmts:Win32_ProcessStartup)".

 [![8](/assets/images/Malware-Analysis/Emotet/8.png)](/assets/images/Malware-Analysis/Emotet/8.png)

 `GetObject(winmgmts:Win32_ProcessStartup).ShowWindow = 0`
 then sets the parameter of "GetObject(winmgmts:Win32_ProcessStartup).ShowWindow" to a value of 0.

[![9](/assets/images/Malware-Analysis/Emotet/9.png)](/assets/images/Malware-Analysis/Emotet/9.png)

`jDD_UwDB = GetObject(winmgmts:Win32_Process).Create`
 Variable jDD_UwDB is defined with the string "GetObject(winmgmts:Win32_Process).Create".

 We can conclude from those parts the VBA code references Windows Management Instrumentation (WMI) classes winmgmts:Win32_ProcessStartup and winmgmts:Win32_Process. The macro uses WMI (Windows Management Instrumentation) to indirectly run PowerShell. The process is launched as a child process of WmiPrvSe.exe (WMI Provider Host).

## PowerShell Analysis

extract powershell string:

[![10](/assets/images/Malware-Analysis/Emotet/10.png)](/assets/images/Malware-Analysis/Emotet/10.png)

Base64 encoded, after decoded:

[![11](/assets/images/Malware-Analysis/Emotet/11.png)](/assets/images/Malware-Analysis/Emotet/11.png)

After decoding the Base64 encoded string, the output illustrated in Figure is produced. The command is obfuscated using the same string joining and case mismatch techniques to evade detection. The decoded string contains many `+` characters that are used to concatenate strings, and a mixture of uppercase and lowercase characters. By removing all the `+` and `''` characters the deobfuscated command is revealed:

[![12](/assets/images/Malware-Analysis/Emotet/12.png)](/assets/images/Malware-Analysis/Emotet/12.png) | [![13](/assets/images/Malware-Analysis/Emotet/12.png)](/assets/images/Malware-Analysis/Emotet/13.png)

The PowerShell command above compress and decodes another Base64 encoded string and reads it as a flow until it reaches the end of the chain. Then it runs the resulting output in memory using the `iex` alias of the Invoke-Expression cmdlet. This is a technique for executing commands in memory without saving files to disk. The command uses the variable `$Verbosepreference` which contains the string `SilentlyContinue`. The first and third characters (`i` and` e`) are identified from the string, which are then joined by `X`, to form the text string` ieX`.
The de obfuscated PowerShell script first splits the string assigned to the variable $XXQCZAxA using the “@” character as a delimiter and then enters a ForEach loop, which iterates the resulting array of URLs(hxxp://dautudatnenhoalac[.]com/wp-admin/DYAsI/)(hxxp://www.bewebpreneur[].]com/wp-admin/daHN/) to download the Emotet loader to the victim’s filesystem using the `Net.WebClient` class. The script uses the environment variable `$env:userProfile` to fetch the user profile directory of the currently logged-in user. The downloaded file is saved to the victim’s user profile directory `(typically C:\Users\[Username])` and set the file name with variable `TQQZoAGU` and this variable it equal 15 so the file will drop it called `15.exe`

[![14](/assets/images/Malware-Analysis/Emotet/14.png)](/assets/images/Malware-Analysis/Emotet/14.png) | [![15](/assets/images/Malware-Analysis/Emotet/15.png)](/assets/images/Malware-Analysis/Emotet/15.png) | [![16](/assets/images/Malware-Analysis/Emotet/16.png)](/assets/images/Malware-Analysis/Emotet/16.png)

As we can see when we run the command, it sends a HTTP GET request to retrieve the second-stage Emotet executable from (hxxp://dautudatnenhoalac[.]com/wp-admin/DYAsI). The response from the web server indicates that the file served is called s17zjCTuWfNF.exe and that the payload is a PE format file as indicated by the ASCII representation of the magic bytes 0x4D5A `MZ` at the start of the file.

`Notice: The ForEach loop exits when check the file is large than 40 KB but when used fake net you will see the file is 2kb cause it's fake simulation. run the file to see real executable file`

[![17](/assets/images/Malware-Analysis/Emotet/17.png)](/assets/images/Malware-Analysis/Emotet/17.png)

And here it is, as we mentioned before the macro uses WMI (Windows Management Instrumentation) to indirectly run PowerShell. The process is launched as a child process of WmiPrvSe.exe (WMI Provider Host).

# <u> Second Stage: Executable File </u>

| Fingerprint                       | Value                                                        |
| --------------------------------- | ------------------------------------------------------------ |
| MD5:                                | 322f9ca84dfa866cb719b7aecc249905                             |
| SHA-1:                              | 147ddeb14bfcc1ff2ee7ef6470ca9a720e61aeaa                     |
| SHA-256:                            | af2f82adf716209cd5ba1c98d0dcd2d9a171bb0963648bd8bd962edb52761241 |
| File Type:                          | PE32 executable (GUI) Intel 80386, for MS Windows            |
| File Size:                          | 428808 bytes                                                 |
| Compiled:                           | Fri Mar 15 19:49:00 2019                                     |

## Static Analysis

[![18](/assets/images/Malware-Analysis/Emotet/18.png)](/assets/images/Malware-Analysis/Emotet/18.png)

in sections, notice in the `.rsrc` (resource) the file in front of us occupies only 51% of the real file space, which means that the program is packed.

[![19](/assets/images/Malware-Analysis/Emotet/19.png)](/assets/images/Malware-Analysis/Emotet/19.png) | [![20](/assets/images/Malware-Analysis/Emotet/20.png)](/assets/images/Malware-Analysis/Emotet/20.png)

We notice in the resource label, there are two unfamiliar resources called EXCEPT and CALIBRATE, the `EXCEPT` have high entropy and large size This makes you think that it is encrypted payload. After dumbed the resource we notice there are encrypted data.

## Behavioral Analysis

First: After, downloading the emotet it lunches itself and first launcher lunches another instance from the same location(C:\Users\[username]) as a child process and copied itself to `C:\Windows\SysWOW6` with different name, in my stat the name is `devneutral.exe`

[![21](/assets/images/Malware-Analysis/Emotet/21.png)](/assets/images/Malware-Analysis/Emotet/21.png)

The process creates a service to indirectly launch the loader. In the call to `CreateService`, the BinaryPath points to `C:\Windows\SysWOW64\devneutral.exe` and the DesiredAccess is 18. This value grants `SERVICE_CHANGE_CONFIG` and `SERVICE_START` access permissions to the service.
And, create some libraries, read them as we can see:

[![22](/assets/images/Malware-Analysis/Emotet/22.png)](/assets/images/Malware-Analysis/Emotet/22.png)

After, read the created libraries, we notice in threads and process activity it loaded it and their some interesting libraries like: `kernall32.dll - crypt32.dll - mswsock.dll - urlmon.dll`.

[![23](/assets/images/Malware-Analysis/Emotet/23.png)](/assets/images/Malware-Analysis/Emotet/23.png)

And, here all registries it implementation with emotet and interesting one is `{aa5b6a80-b834-11d0-932f-00a0c90dcaa9}` which is passed as a parameter to `RegOpenKeyA`. This registry key is required for the Windows scripting engine interface

[![24](/assets/images/Malware-Analysis/Emotet/24.png)](/assets/images/Malware-Analysis/Emotet/24.png)

After registering itself as service, `devneutral.exe` is launched by services.exe. and downloads the next stage payload from a remote server.
Then collects system information and sends it through an encrypted channel to its command and control (C2) servers in the data section of HTTP POST requests and receives further commands and payloads from the servers as a response. The loader also downloads modules to extend the functionality of the loader as well as other malware families.

[![25](/assets/images/Malware-Analysis/Emotet/25.png)](/assets/images/Malware-Analysis/Emotet/25.png) | [![26](/assets/images/Malware-Analysis/Emotet/26.png)](/assets/images/Malware-Analysis/Emotet/26.png)

`Notice: Emotet sent encrypted C2 data as cookie values in the headers of HTTP GET requests.`

## Binary Analysis

The `start` function that generates an array of characters and has a conditional while (true) infinite loop. The function works by reading a Windows Registry key through a call to `RegOpenKeyA`. If the key is not found, the malware enters an infinite loop

[![27](/assets/images/Malware-Analysis/Emotet/27.png)](/assets/images/Malware-Analysis/Emotet/27.png) | [![28](/assets/images/Malware-Analysis/Emotet/28.png)](/assets/images/Malware-Analysis/Emotet/28.png)

The `sub_401A90` function  decodes a string with the value `interface\{aa5b6a80-b834-11d0-932f-00a0c90dcaa9}`(mentioned it before) which is passed as a parameter to `RegOpenKeyA`

[![29](/assets/images/Malware-Analysis/Emotet/29.png)](/assets/images/Malware-Analysis/Emotet/29.png) | [![30](/assets/images/Malware-Analysis/Emotet/30.png)](/assets/images/Malware-Analysis/Emotet/30.png)

The important function, It sparked my attention is `VirtualAllocEx`. This function is used to allocate memory in a remote process and is often used by emotet for process injection. We will start by putting a breakpoint on the return address for `VirtualAllocEx`.

First: After, open `15.exe` in x32dbg go to `symbols`, search for `VirtualAlloc`, but breakpoint on the address of function `VirtualAllocEx` and run.

[![32](/assets/images/Malware-Analysis/Emotet/32.png)](/assets/images/Malware-Analysis/Emotet/32.png)

Then: but breakpoint on `ret` (return of function) and run.

[![33](/assets/images/Malware-Analysis/Emotet/33.png)](/assets/images/Malware-Analysis/Emotet/33.png)

If we run until the breakpoint, we see that emotet creates an allocation of memory at `0x00011200`. It then copies a code stub from the .data section of the mapped image at 0x00470000 to the newly allocated memory space and gives control to it.

[![34](/assets/images/Malware-Analysis/Emotet/34.png)](/assets/images/Malware-Analysis/Emotet/34.png) | [![35](/assets/images/Malware-Analysis/Emotet/35.png)](/assets/images/Malware-Analysis/Emotet/35.png)

Before breakpoint:

[![36](/assets/images/Malware-Analysis/Emotet/36.png)](/assets/images/Malware-Analysis/Emotet/36.png)

Emotet then deobfuscates API and DLL names from the code copied to `0x00011200`, like `LoadLibraryExA`, `kernel32.dll` and `VirtualAlloc`

[![37](/assets/images/Malware-Analysis/Emotet/37.png)](/assets/images/Malware-Analysis/Emotet/37.png) | [![38](/assets/images/Malware-Analysis/Emotet/38.png)](/assets/images/Malware-Analysis/Emotet/38.png)

It then calls `GetProcAddress` from `kernel32.dll` to get the addresses of the decoded API names.

The functions decoded:
```
LoadLibraryExA   
GetProcAddress
VirtualAlloc   
GetModuleHandleA
UnmapViewOfFile
WriteFile
SetFilePointer  
Sleep
LstrlenA   
LstrcatA   
VirtualProtect
CloseHandle   
VirtualFree   
GetTempPathA
CreateFileA
```

The emotet loader calls `GetProcAddress` for an invalid function name called `mknjht34tfserdgfwGetProcAddress`. Since this is invalid, the function returns a null value with an error code of `0000007F (ERROR_PROC_NOT_FOUND)`.

[![41](/assets/images/Malware-Analysis/Emotet/41.png)](/assets/images/Malware-Analysis/Emotet/41.png)

Once the code stub has retrieved the function addresses, `VirtualAlloc` is called to allocate another memory region where it writes the decrypted PE file from the .data section of 15.exe, rather than from the `.rsrc` section.

[![42](/assets/images/Malware-Analysis/Emotet/42.png)](/assets/images/Malware-Analysis/Emotet/42.png)

# <u> Third Stage: Unpacked Executable File </u>

| Fingerprint                       | Value                                                        |
| --------------------------------- | ------------------------------------------------------------ |
| MD5:                                | D623BD93618B6BCA25AB259DE21E8E12                             |
| SHA-1:                              | BBE1BFC57E8279ADDF2183F8E29B90CFA6DD88B4                     |
| SHA-256:                            | 01F86613FD39E5A3EDCF49B101154020A7A3382758F36D875B12A94294FBF0EA |


Dumping the executable and examining it reveals that it is another packed Emotet binary that contains the main loader.

[![43](/assets/images/Malware-Analysis/Emotet/43.png)](/assets/images/Malware-Analysis/Emotet/43.png)

After API name resolution, GetCurrentProcessId is called to get the process ID (PID) of Emotet‘s running process. Afterwards, Emotet iterates through all running processes to find its module name and parent PID. Once it finds its parent PID, it creates two mutexes with the format PEM%X. One of the mutexes is created using the parent process ID (PEM[PPID]) and the other uses its own PID (PEM[PID]).

After creating these mutexes, it calls CreateEventW to create an event using the format PEE%X, where %X is its parent PID. If both mutexes are successfully created, it launches 15.exe again from the same path. After launching the child process, it calls WaitForSingleObject on the PEE%X event.

We have seen in some of the Emotet samples that it launches child process with a command line switch. This command line switches are an indication that an Emotet process has been launched as a child process and has to perform a designated task.

The launched child process does everything same until it evaluates whether to create the two mutexes described above. This time the call to CreateMutex for mutex PEM[PPID] fails with the error “ERROR_ALREADY_EXISTS”. After the mutex creation fails in the child process, it signals the event PEE[PPID] to the parent process 15.exe. The parent process exits from a waiting state and then terminates itself.

# <u> IOCs </u>

## <u> Hashes (MD5): </u>

First Stage: 57be28414e61ff58a6b52fc3c1b70b7f<br>

Second Stage: 322f9ca84dfa866cb719b7aecc249905<br>

Third Stage: D623BD93618B6BCA25AB259DE21E8E12<br>

## <u> Domains Requests: </u>

hxxp://dautudatnenhoalac[.]com/wp-admin/DYAsI/<br>

hxxp://www.bewebpreneur[.]com/wp-admin/daHN/<br>

hxxp://82.78.228[.]57:443/free/tlb/<br>

## <u> IPs</u>

103.237.145.132<br>

192.241.233.63<br>

82.78.228.57<br>

# <u> References </u>

[https://app.any.run/tasks/1879ad1f-ac52-4fba-9230-9cffee29e6cc](https://app.any.run/tasks/1879ad1f-ac52-4fba-9230-9cffee29e6cc)

[https://medium.com/swlh/static-analysis-of-the-emotet-malware-f94b16aa8f70](https://medium.com/swlh/static-analysis-of-the-emotet-malware-f94b16aa8f70)

[https://www.malwarebytes.com/emotet/](https://www.malwarebytes.com/emotet/)

[https://www.fortinet.com/blog/threat-research/deep-dive-into-emotet-malware](https://www.fortinet.com/blog/threat-research/deep-dive-into-emotet-malware)

[https://www.fortinet.com/blog/threat-research/deep-dive-into-emotet-malware](https://threatresearch.ext.hp.com/emotet-analysis-part-3/) and Part [1,2]
